# CTA2045 module

This module aims at providing a translation from natural language to CTA2045. For example, it translates `shed` to its corresponding hex byte representation. It also provides the translation in the opposite direction (from hex bytes to natural language). The hope is to ease understanding & use of the CTA2045 standard.  
 
 ## Features

What do I want to say???:
* from_cta
* to_cta
    * UnknownCommandException
    * UnsupportedCommandException
* hexify
* unhexify
* parse_hex
* complement 
* set_supported
* is_valid
* from_cta_bytes
* to_cta_bytes
* get_code_value
* dump_commands
    * The library relies on a JSON file as an input translation. The JSON file contains the (known) commands and information about each of them. Modifying the JSON file (`CTA2045_commands.json`) enables one to add or remove support for CTA2045 commands. Moreover, each command has a `supported` field that specifies whether the corresponding command should be supported by the library or not. See the bulletpoints of `set_supported` and _Adding support for more commands_ section for more information.
    * The `dump_commands` method returns a dictionary of all the supported CTA2045 commands by the library.

# Adding support for more commands
The `CTA2045_commands.json` file contains information about the supported commands. Each command has fields that are used by the library for translation purposes. The fields include:
        * Type: used to indicate what type of CTA2045 the command is (`basic`, `link` for link-layer, `intermediate`, etc..).
        * format: used to express the format of the command in hex bytes. It also includes codes (along a mapping of what they represent) like `CC`, `H`, etc... that are used in translation. For example, the `H` translates to hash, which is used to indicate this message should end with a checksum digest. Other codes are used to indicate arguments of the command. For instance, `D`, which stands for duration, is used to indicate this command takes duration as argument (commands like shed, endshed, etc...). 
        * op1: used to express opcode 1 of the command
        * op2: used to express opcode 2 of the command 
        * supported: used to express wheather this command should be suppoorted by the library by default. This could be changed via a call to `set_supported` method.
To add support for a command, make the following modification to the json file:
1. add an entry for the desired command containing `fype`, `format`, `op1`, `op1`, and `supported` fields under the `commands` field. 
2. If the command uses arguments, ensure the code for each argument is __unique__ and __capitalized__ in the `format` field.
3. For each argument contained in the command, add an entry for under the `codes` field (if it doesn't exist).  
4. Finally, each argument should have its seperate field in the top level of the json file. See `reseved` argument as an example. This field should contain at least `default` and `length` fields. The `dafult` is used to indicate the default value of this argument. The `length` is used to indicate the number of bytes covered by this argument according to CTA2045 standard. 
    * Repeatitive pattern in arguments is expressed by surrounding the arguments with paranthasis (see commodity read respounse for example).
    * If the argument has specific values that can be enumerated, you can add them.
    * __The library will use the first entry as its default__.
    
## Resources
See [CTA2045](link-here) standard documentation.

> For more information, be sure to checkout the DocStrings in the code and the example programs to learn how to use this module 